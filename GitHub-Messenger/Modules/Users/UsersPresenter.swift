//
//  UsersPresenter.swift
//  GitHub-Messenger
//
//  Created by Luqman Fauzi on 3/3/2020.
//
//  This file was generated by the 🐍 VIPER generator
//

import UIKit

final class UsersPresenter {

    // MARK: - Private properties -

    /// Current pagination
    private var pagination = Pagination.first

    /// Current state
    private var state: State? {
        didSet {
            handleStateChange()
        }
    }

    /// Current users list
    private var users: [User] = [] {
        didSet {
            view.reloadData()
        }
    }

    private unowned let view: UsersViewInterface
    private let interactor: UsersInteractorInterface
    private let wireframe: UsersWireframeInterface

    // MARK: - Lifecycle -

    init(view: UsersViewInterface, interactor: UsersInteractorInterface, wireframe: UsersWireframeInterface) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }

    private func loadData(at page: Pagination, completion: (() -> Void)? = nil) {
        interactor.requestData(page: page, completion: { [weak self] (result) in
            switch result {
            case .success(let response):
                self?.state = (page.page == 1) ? .onInitialLoadSucceess(response) : .onPaginationLoadSucces(response)
            case .failure(let errorMessage):
                self?.state = (page.page == 1) ? .onInitialLoadFailed(errorMessage) : .onPaginationLoadFailed(errorMessage)
            }
            completion?()
        })
    }

    /// To handler state change every time `self.state` is being updated
    private func handleStateChange() {
        switch state {
        case .onInitialLoading:
            view.setLoadingView(true)
            view.setListView(false)
            view.setEmptyListView(false)

        case .onInitialLoadSucceess(let response):
            view.setLoadingView(false)
            view.setListView(true)
            view.setEmptyListView(false)

            pagination = Pagination(page: 1, totalCount:  response.users.count, nextPageURL: response.nextURL)
            users = response.users

        case .onInitialLoadFailed(let errorMessage):
            view.showAlertMessage(errorMessage)
            view.setLoadingView(false)
            view.setListView(false)
            view.setEmptyListView(true)

        case .onPaginationLoading:
            view.setLoadingPaginationView(true)
            view.setLoadingPaginationViewWithRetry(false)

        case .onPaginationLoadSucces(let response):
            view.setLoadingPaginationView(false)
            view.setLoadingPaginationViewWithRetry(false)

            pagination = Pagination.next(of: self.pagination, addedCount: response.users.count, url: response.nextURL)
            users += response.users
            if pagination.totalCount >= Constants.maxItemsCount {
                // On reached max items count
                state = .onReachedMaxItemsCount
            }

        case .onPaginationLoadFailed(let errorMessage):
            view.showAlertMessage(errorMessage)
            view.setLoadingPaginationView(false)
            view.setLoadingPaginationViewWithRetry(true)

        case .onReachedMaxItemsCount:
            view.setLoadingPaginationView(false)
            view.setLoadingPaginationViewWithRetry(false)

        case .none:
            return
        }
    }
}

// MARK: - Extensions -

extension UsersPresenter: UsersPresenterInterface {

    func viewDidLoad() {
        view.setupViews()
        state = .onInitialLoading
        loadData(at: Pagination.first)
    }

    func refreshPage(_ sender: UIRefreshControl) {
        loadData(at: Pagination.first, completion: {
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                sender.endRefreshing()
            }
        })
    }

    func retryOnInitialLoad() {
        state = .onInitialLoading
        loadData(at: Pagination.first)
    }

    func retryOnFailedToLoadNextPage() {
        state = .onPaginationLoading
        loadData(at: Pagination.next(of: self.pagination))
    }

    func numberOfSections() -> Int {
        return 1
    }

    func numberOrItems(in section: Int) -> Int {
        return users.count
    }

    func item(at indexPath: IndexPath) -> UserContentItemInterface {
        return users[indexPath.row]
    }

    func didSelectItem(at indexPath: IndexPath) {
        let user = users[indexPath.row]
        wireframe.openMessagingPage(user)
    }

    func checkIfNeedsToLoadNextPage(offsetY: CGFloat, contentSizeHeight: CGFloat, frameHeight: CGFloat) {
        let distanceFromBottom = contentSizeHeight - offsetY
        let needsToLoad = state?.rawValue != State.onPaginationLoading.rawValue

        if distanceFromBottom < frameHeight, needsToLoad {
            state = .onPaginationLoading
            loadData(at: Pagination.next(of: self.pagination))
        }
    }
}


// MARK: - Misc -

extension UsersPresenter {

    /// Constant properties
    private struct Constants {
        static let maxItemsCount: Int = 50
        static let itemsPerPage: Int = 10
    }

    /// Life-cycle states of Users list page
    private enum State {
        case onInitialLoading
        case onInitialLoadSucceess(User.GitHubSuccessResponse)
        case onInitialLoadFailed(String)
        case onPaginationLoading
        case onPaginationLoadSucces(User.GitHubSuccessResponse)
        case onPaginationLoadFailed(String)
        case onReachedMaxItemsCount

        var rawValue: Int {
            switch self {
            case .onInitialLoading: return 1
            case .onInitialLoadSucceess: return 2
            case .onInitialLoadFailed: return 3
            case .onPaginationLoading: return 4
            case .onPaginationLoadSucces: return 5
            case .onPaginationLoadFailed: return 6
            case .onReachedMaxItemsCount: return 7
            }
        }
    }
}
